#!/usr/bin/env python3
# coding: utf-8
"""Generates SQLAlchemy tables from drywall object definitions"""
from drywall import objects

class FauxTable:
	"""Table to be turned into an SQLAlchemy table"""
	def __init__(self, class_name, table_name):
		self.class_name = class_name
		self.table_name = table_name
		self.columns = {}
		self.columns['id'] = "Column('id', String(255), primary_key=True)"
	def dump_orm(self):
		print("class " + self.class_name + "(Base, CustomSerializerMixin):")
		print("	__tablename__ = '" + self.table_name + "'")
		print("")
		for col_name, col_info in self.columns.items():
			print("	" + col_name + " = " + col_info)
		print("")

def get_object_properties(object):
	"""Returns a dict containing the properties of an object."""
	properties = {}
	for prop in ['type', 'object_type', 'valid_keys', 'required_keys',
				'default_keys', 'key_types', 'id_key_types',
				'nonrewritable_keys', 'unique_keys']:
		if hasattr(object, prop):
			properties[prop] = getattr(object, prop)
		else:
			properties[prop] = None
	return properties

def key_type_to_sql(key_type):
	"""Turns a key type to an SQL-compatible column type"""
	if key_type == "string":
		return "Text"
	elif key_type == "number":
		return "Integer"
	elif key_type == "boolean":
		return "Boolean"
	elif key_type == "permission_map":
		return "SmallInteger"
	elif key_type == "datetime":
		return "DateTime"
	elif key_type == "id":
		return "String(255)"
	elif key_type in ["list", "id_list"]:
		return "postgresql.ARRAY(String(255))"
	else:
		raise TypeError("wrong key type " + key_type)

def is_unique(object_properties, key):
	"""Checks if key is unique and returns ORM statement if needed"""
	if object_properties['unique_keys'] and key in object_properties['unique_keys']:
		return "unique=True"
	return ""

def is_required(object_properties, key):
	"""Checks if key is required and returns ORM statement if needed"""
	if object_properties['required_keys'] and key in object_properties['required_keys']:
		return "nullable=False"
	return ""

def is_id(object_properties, key):
	"""Checks if key contains an ID and returns ORM relationship statement if needed"""
	if object_properties['key_types'][key] == "id":
		id_key_type = object_properties['id_key_types'][key]
		if id_key_type == 'any':
			return "ForeignKey('objects.id')"
		else:
			return "ForeignKey('" + id_key_type + ".id')"
	return ""

def set_defaults(object_properties, key):
	"""
	Sets default values for booleans and dates; all bools are NULL if the
	default is not set.
	"""
	key_type = object_properties['key_types'][key]
	if key_type == "boolean":
		return "default=" + str(object_properties['default_keys'][key])
	return ""


def ormify(args):
	"""Turns arguments into a string with settings that can be appended
	to an ORM Column statement if needed"""
	args = [i for i in args if i]
	final_string = ""
	arg_count = 0
	args_total = len(args)
	for arg in args:
		arg_count = arg_count + 1
		if arg:
			final_string = final_string + str(arg)
			if arg_count != args_total:
				final_string = final_string + ", "
	if final_string:
		final_string = ", " + final_string
	return final_string

object_tables = {}

print("""# The following tables have been generated by alchemify.py from the
# drywall utilities. For more information, see the documentation:
# https://punctum-im.github.io/drywall/dev/alchemify""")

print("""
from sqlalchemy import Column, ForeignKey
from sqlalchemy import Integer, String, DateTime, Boolean, SmallInteger, Text
from sqlalchemy.orm import declarative_base
from sqlalchemy.dialects import postgresql
from sqlalchemy_serializer import SerializerMixin
import datetime

Base = declarative_base()

class CustomSerializerMixin(SerializerMixin):
	# TODO: Ideally we'd just set datetime_format to None to set it to isoformat,
	#       but that leaves out the +00:00 suffix, because we're missing
	#       ".replace(tzinfo=datetime.timezone.utc)" from the call. We could
	#       set it manually, but that's less efficient than just hardcoding it
	#       here. We force UTC as the timezone, so it shouldn't cause any issues,
	#       but maybe we can negotiate a feature for this with upstream?
	tzinfo = datetime.timezone.utc
	datetime_format = '%Y-%m-%dT%H:%M:%S.%f+00:00'""")

print("""
# Main object lookup table
class Objects(Base):
	__tablename__ = 'objects'

	id = Column(String(255), primary_key=True)
	object_type = Column(String(255), nullable=False)
""")

for object in objects.objects:
	object_type = object.object_type
	object_table = FauxTable(object.__name__, object_type)
	object_properties = get_object_properties(object)
	print("# " + object_type)
	for key in object.valid_keys:
		object_table.columns[key] = "Column(" + key_type_to_sql(object.key_types[key]) + ormify([is_id(object_properties, key),
			is_required(object_properties, key),
			is_unique(object_properties, key),
			set_defaults(object_properties, key)]) + ")"
	object_table.dump_orm()
	object_tables[object_type] = object_table

print("""# User
class User(Base, SerializerMixin):
	__tablename__ = "users"

	account_id = Column(String(255), nullable=False, unique=True)
	email = Column(String(255), primary_key=True)
	username = Column(String(255), nullable=False, unique=True)
	password = Column(Text, nullable=False)""")

print("""
# Helper functions
""")

print("""def object_type_to_model(object_type):
	\"""
	Takes an object_type string and returns the ORM model class for that
	object type.
	\"""
""")

_if = "if"
for object in objects.objects:
	print("	" + _if + " object_type == '" + object.object_type + "':")
	print("		return " + object.__name__)
	_if = "elif"
print("	else:")
print("		raise TypeError('Incorrect object_type')")

print("""
# End of auto-generated tables
""")

